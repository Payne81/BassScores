#pragma once

//https://www.cnblogs.com/sz-leez/p/7119232.html（简易了解）

//https://blog.csdn.net/longjialin93528/article/details/80160467（完整版）
//内存对齐：
/*
	1.结构体内成员按自身按自身长度自对齐。
		自身长度，如char = 1，short = 2，int = 4，double = 8, 。所谓自对齐，
		指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如int只能以0, 4, 8这类的地址开始
	2.结构体的总大小为结构体的有效对齐值的整数倍
*/
/*
1.空类
class A
{
};

sizeof(A); //1
解析：类的实例化就是为每个实例在内存中分配一块地址；每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会隐含地为其添加一个字节，以作区分。
2.虚函数类
class A
{
	virtual void Fun();
};

sizeof(A); //4
解析：当一个类中包含虚函数时，会有一个指向其虚函数表的指针vptr，系统为类指针分配大小为4个字节(即使有多个虚函数)。
3.普通数据成员

class A
{
	int a;
	char b;
};

sizeof(A); //8

解析：普通数据成员，按照其数据类型分配大小，由于字节对齐，所以a+b=8字节。
4.静态数据成员

class A
{
	int a;
	static int b;
};

sizeof(A); //4

解析：静态数据成员存放的是全局数据段，即使它是类的一个成员，但不影响类的大小；不管类产生多少实例或者派生多少子类，静态成员数据在类中永远只有一个实体存在。而类的非静态数据成员只有被实例化时，才存在，但类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在，类的静态数据成员可以说是一种特殊的全局变量。
5.普通成员函数
class A
{
	void Fun();
};

sizeof(A); //1
解析：类的大小与它的构造函数、析构函数以及其他成员函数无关，只与它的数据成员相关。
6.普通继承

class A
{
	int a;
};

class B:public A
{
	int b;
};

sizeof(B); //8

解析：普通类的继承，类的大小为本身数据成员大小+基类数据成员大小。
7.虚函数继承

virtual class A
{
	int a;
};

class B:virtual public A
{
	int b;
};

sizeof(B); //12

解析：虚函数类的继承，派生类大小=派生类自身成员大小+基类数据成员大小+虚拟指针大小（即使继承多个虚基类，也只有一个指向其虚函数表的指针vptr，大小为4字节）
*/